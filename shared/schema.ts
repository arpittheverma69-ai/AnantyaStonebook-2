import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, decimal, boolean, timestamp, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Enhanced Gemstone Inventory Table
export const inventory = pgTable("inventory", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  gemId: text("gem_id").notNull().unique(), // Generated by system (e.g., RUBY-001)
  type: text("type").notNull(), // Ruby, Blue Sapphire, Emerald, etc.
  grade: text("grade").notNull().default("A"), // A, AA, AAA, AAAA
  carat: decimal("carat", { precision: 10, scale: 2 }).notNull(),
  origin: text("origin").notNull(), // Sri Lanka, Myanmar, Thailand, etc.
  customOrigin: text("custom_origin"), // Custom origin field
  pricePerCarat: decimal("price_per_carat", { precision: 15, scale: 2 }).notNull(),
  totalPrice: decimal("total_price", { precision: 15, scale: 2 }).notNull(),
  isAvailable: boolean("is_available").default(true),
  quantity: integer("quantity").default(1),
  imageUrl: text("image_url"), // URL to gemstone image
  description: text("description"), // Detailed description
  aiAnalysis: text("ai_analysis"), // AI-powered analysis
  supplierId: varchar("supplier_id").references(() => suppliers.id),
  certified: boolean("certified").default(false),
  certificateLab: text("certificate_lab"), // IGI, IIGJ, GJEPC
  certificateFile: text("certificate_file"), // File path/URL
  status: text("status").notNull().default("In Stock"), // In Stock, Sold, Reserved
  packageType: text("package_type"), // Velvet, Leatherette
  notes: text("notes"),
  tags: text("tags").array().default([]), // Premium, Budget, High-Demand
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Clients Table
export const clients = pgTable("clients", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  clientType: text("client_type").notNull(), // Astrologer, Jeweler, Temple
  city: text("city").notNull(),
  state: text("state"), // <-- Add this line
  phone: text("phone"),
  email: text("email"),
  address: text("address"),
  gstNumber: text("gst_number"), // GST registration number
  businessName: text("business_name"), // Business name for GST
  businessAddress: text("business_address"), // Business address for GST
  loyaltyLevel: text("loyalty_level").default("Medium"), // High, Medium, Low
  isTrustworthy: boolean("is_trustworthy").default(true), // <-- Add this line
  isRecurring: boolean("is_recurring").default(false), // <-- Add this line
  notes: text("notes"),
  tags: text("tags").array().default([]), // Bulk Buyer, Premium, Inactive
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Suppliers Table
export const suppliers = pgTable("suppliers", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  location: text("location").notNull(), // Jaipur, Surat, Bangkok, etc.
  phone: text("phone"),
  email: text("email"),
  address: text("address"),
  type: text("type").notNull(), // Domestic, International
  gemstoneTypes: text("gemstone_types").array().default([]),
  certificationOptions: text("certification_options"),
  notes: text("notes"),
  tags: text("tags").array().default([]), // Reliable, Delay-prone, High-Quality
  arrivalDate: timestamp("arrival_date"),
  departureDate: timestamp("departure_date"),
  city: text("city"),
  state: text("state"),
  gstNumber: text("gst_number"),
  landmark: text("landmark"),
  totalAmount: decimal("total_amount", { precision: 15, scale: 2 }),
  totalSold: decimal("total_sold", { precision: 15, scale: 2 }),
  qualityRating: integer("quality_rating").default(0), // 1-5 star rating
  reliabilityScore: integer("reliability_score").default(0), // 1-5 star rating
  lastTransactionDate: timestamp("last_transaction_date"),
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Sales Table
export const sales = pgTable("sales", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  saleId: text("sale_id").notNull().unique(),
  date: timestamp("date").notNull(),
  clientId: varchar("client_id").references(() => clients.id),
  stoneId: varchar("stone_id").references(() => inventory.id),
  quantity: integer("quantity").default(1),
  totalAmount: decimal("total_amount", { precision: 15, scale: 2 }).notNull(),
  profit: decimal("profit", { precision: 15, scale: 2 }).notNull(),
  invoiceFile: text("invoice_file"), // File path/URL
  paymentStatus: text("payment_status").notNull().default("Unpaid"), // Paid, Partial, Unpaid
  notes: text("notes"),
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Sale Items Table (supports multi-item sales)
export const saleItems = pgTable("sale_items", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  saleId: varchar("sale_id").notNull().references(() => sales.id),
  stoneId: varchar("stone_id").notNull().references(() => inventory.id),
  quantity: integer("quantity").default(1),
  carat: decimal("carat", { precision: 10, scale: 2 }).notNull(),
  pricePerCarat: decimal("price_per_carat", { precision: 15, scale: 2 }).notNull(),
  totalPrice: decimal("total_price", { precision: 15, scale: 2 }).notNull(),
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Certification Tracker Table
export const certifications = pgTable("certifications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  stoneId: varchar("stone_id").references(() => inventory.id),
  lab: text("lab").notNull(), // IGI, IIGJ, GJEPC
  dateSent: timestamp("date_sent"),
  dateReceived: timestamp("date_received"),
  certificateFile: text("certificate_file"), // File path/URL
  status: text("status").notNull().default("Pending"), // Pending, Received
  notes: text("notes"),
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Consultations Table
export const consultations = pgTable("consultations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  clientName: text("client_name").notNull(),
  clientPhone: text("client_phone").notNull(),
  clientEmail: text("client_email").notNull(),
  consultationType: text("consultation_type").notNull(), // Initial, Follow-up, Emergency, Routine, VIP
  consultationDate: timestamp("consultation_date").notNull(),
  consultationTime: text("consultation_time").notNull(),
  duration: text("duration").notNull(), // 15 min, 30 min, 45 min, 1 hour, etc.
  gemstoneInterest: text("gemstone_interest").array().default([]),
  budget: text("budget").notNull(), // Budget range
  urgency: text("urgency").notNull().default("Medium"), // Low, Medium, High, Critical
  consultationStatus: text("consultation_status").notNull().default("Scheduled"), // Scheduled, In Progress, Completed, Cancelled, Rescheduled
  consultationNotes: text("consultation_notes").notNull(),
  followUpRequired: boolean("follow_up_required").default(false),
  followUpDate: timestamp("follow_up_date"),
  followUpNotes: text("follow_up_notes"),
  recommendations: text("recommendations").notNull(),
  nextSteps: text("next_steps").notNull(),
  clientSatisfaction: integer("client_satisfaction"), // 1-5 rating
  specialRequirements: text("special_requirements"),
  location: text("location").notNull(),
  consultationMethod: text("consultation_method").notNull(), // In-Person, Video Call, Phone Call, WhatsApp, Email
  paymentStatus: text("payment_status").notNull().default("Pending"), // Pending, Partial, Completed, Waived
  consultationFee: text("consultation_fee"),
  tags: text("tags").array().default([]),
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Tasks Table
export const tasks = pgTable("tasks", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  status: text("status").default("Pending"), // Pending, In Progress, Completed
  description: text("description"),
  notes: text("notes"),
  relatedTo: varchar("related_to"), // Client ID, Stone ID, etc.
  relatedType: text("related_type"), // Client, Stone, Supplier, etc.
  assignedTo: varchar("assigned_to"), // User ID
  dueDate: timestamp("due_date"),
  priority: text("priority").default("Medium"), // High, Medium, Low
  completed: boolean("completed").default(false),
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Users Table
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  role: text("role").notNull().default("user"), // admin, user
  createdAt: timestamp("created_at").default(sql`now()`),
  updatedAt: timestamp("updated_at").default(sql`now()`),
});

// Zod schemas for validation
export const insertInventorySchema = createInsertSchema(inventory, {
  type: z.string().min(1, "Gemstone type is required"),
  grade: z.enum(["A", "AA", "AAA", "AAAA"]),
  carat: z.number().positive("Carat must be positive"),
  origin: z.string().min(1, "Origin is required"),
  pricePerCarat: z.number().positive("Price per carat must be positive"),
  totalPrice: z.number().positive("Total price must be positive"),
  quantity: z.number().int().positive("Quantity must be a positive integer"),
  certified: z.boolean().optional(),
  certificateLab: z.string().optional(),
  certificateFile: z.string().optional(),
});

export const insertClientSchema = createInsertSchema(clients, {
  name: z.string().min(1, "Name is required"),
  clientType: z.string().min(1, "Client type is required"),
  city: z.string().min(1, "City is required"),
});

export const insertSupplierSchema = createInsertSchema(suppliers, {
  name: z.string().min(1, "Name is required"),
  location: z.string().min(1, "Location is required"),
  type: z.string().min(1, "Type is required"),
});

export const insertSaleSchema = createInsertSchema(sales, {
  saleId: z.string().min(1, "Sale ID is required"),
  date: z.date(),
  totalAmount: z.number().positive("Total amount must be positive"),
  profit: z.number(),
});

export const insertCertificationSchema = z.object({
  lab: z.string().min(1, "Lab is required"),
  stoneId: z.string().optional(),
  dateSent: z.string().optional().transform((val) => val ? new Date(val) : null),
  status: z.string().optional(),
  notes: z.string().optional(),
  certificateFile: z.string().optional(),
});

export const insertConsultationSchema = createInsertSchema(consultations, {
  date: z.date(),
  medium: z.string().min(1, "Medium is required"),
});

export const insertTaskSchema = createInsertSchema(tasks, {
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  notes: z.string().optional(),
  relatedTo: z.string().optional(),
  relatedType: z.string().optional(),
  assignedTo: z.string().optional(),
  dueDate: z.union([z.date(), z.string()]).optional().transform((val) => {
    if (!val) return undefined;
    return typeof val === 'string' ? new Date(val) : val;
  }),
  priority: z.string().optional(),
  status: z.string().optional(),
  completed: z.boolean().optional(),
});

export const insertUserSchema = createInsertSchema(users, {
  username: z.string().min(1, "Username is required"),
  password: z.string().min(1, "Password is required"),
});

// TypeScript types
export type Inventory = typeof inventory.$inferSelect;
export type InsertInventory = z.infer<typeof insertInventorySchema>;

export type Client = typeof clients.$inferSelect;
export type InsertClient = z.infer<typeof insertClientSchema>;

export type Supplier = typeof suppliers.$inferSelect;
export type InsertSupplier = z.infer<typeof insertSupplierSchema>;

export type Sale = typeof sales.$inferSelect;
export type InsertSale = z.infer<typeof insertSaleSchema>;

export type Certification = typeof certifications.$inferSelect;
export type InsertCertification = z.infer<typeof insertCertificationSchema>;

export type Consultation = typeof consultations.$inferSelect;
export type InsertConsultation = z.infer<typeof insertConsultationSchema>;

export type Task = typeof tasks.$inferSelect;
export type InsertTask = z.infer<typeof insertTaskSchema>;

export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
